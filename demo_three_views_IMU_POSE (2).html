<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ä¸‰è§†å›¾æ¼”ç¤ºï¼šPose + IMU + èåˆ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: #1a1a2e;
            color: white;
            overflow: hidden;
        }
        
        .layout {
            display: grid;
            grid-template-columns: 250px 1fr 1fr 1fr;
            height: 100vh;
            gap: 10px;
            padding: 10px;
        }
        
        .control-panel {
            background: #0f1419;
            padding: 15px;
            overflow-y: auto;
        }
        
        .view-panel {
            background: #0f0f1e;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .view-title {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10;
        }
        
        .view-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
        }
        
        #poseCanvas, #imuCanvas, #fusionCanvas {
            width: 100%;
            height: 100%;
        }
        
        #poseCanvas {
            background: black;
        }
        
        video {
            display: none;
        }
        
        h2 {
            color: #3498db;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .section {
            background: rgba(52, 152, 219, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }
        
        .section h3 {
            color: #3498db;
            font-size: 0.9em;
            margin-bottom: 10px;
        }
        
        .btn {
            width: 100%;
            padding: 10px;
            margin: 6px 0;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn:hover { transform: translateY(-2px); }
        .btn-primary { background: linear-gradient(135deg, #3498db, #2980b9); }
        .btn-warning { background: linear-gradient(135deg, #f39c12, #e67e22); }
        
        .data-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 0.85em;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .data-label { color: #95a5a6; }
        .data-value {
            font-weight: bold;
            color: #2ecc71;
            font-family: monospace;
        }
        
        .status {
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.8em;
            display: inline-block;
        }
        .status.active { background: #2ecc71; }
        .status.inactive { background: #e74c3c; }
    </style>
</head>
<body>
    <div class="layout">
        <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
        <div class="control-panel">
            <h2>ğŸ¯ æ§åˆ¶å°</h2>
            
            <div class="section">
                <h3>ğŸ“± è®¾å¤‡</h3>
                <button class="btn btn-primary" onclick="startPose()">ğŸ“¹ å¯åŠ¨Pose</button>
                <button class="btn btn-primary" onclick="connectIMU()">ğŸ® è¿æ¥IMU</button>
                <div style="margin-top:8px;">
                    <div class="data-row">
                        <span>Pose</span>
                        <span class="status inactive" id="poseStatus">æœªå¯åŠ¨</span>
                    </div>
                    <div class="data-row">
                        <span>IMU</span>
                        <span class="status inactive" id="imuStatus">æœªè¿æ¥</span>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3>ğŸ”§ æ ¡å‡†</h3>
                <button class="btn btn-warning" onclick="calibrateIMU()">æ ¡å‡†IMUé›¶ç‚¹</button>
                <button class="btn btn-warning" onclick="calibrateFusion()">æ ¡å‡†èåˆ</button>
                <div id="calibStatus" style="margin-top:8px; font-size:0.8em; color:#f39c12;"></div>
            </div>
            
            <div class="section">
                <h3>ğŸ§­ IMUå§¿æ€</h3>
                <div class="data-row">
                    <span class="data-label">Roll</span>
                    <span class="data-value" id="roll">0.0Â°</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Pitch</span>
                    <span class="data-value" id="pitch">0.0Â°</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Yaw</span>
                    <span class="data-value" id="yaw">0.0Â°</span>
                </div>
            </div>
            
            <div class="section">
                <h3>ğŸ’¡ è¯´æ˜</h3>
                <div style="font-size:0.8em; line-height:1.5;">
                    <strong>å·¦ï¼šPoseæ£€æµ‹</strong><br>
                    33ä¸ªå…¨èº«å…³é”®ç‚¹<br>
                    æ‰‹è…•ä½ç½®å‡†ç¡®<br><br>
                    
                    <strong>ä¸­ï¼šIMU 3D</strong><br>
                    æ‰‹éƒ¨æ¨¡å‹å§¿æ€<br>
                    æ—‹è½¬IMUè§‚å¯Ÿ<br><br>
                    
                    <strong>å³ï¼šèåˆ</strong><br>
                    ä½ç½®æ¥è‡ªPose<br>
                    å§¿æ€æ¥è‡ªIMU
                </div>
            </div>
        </div>
        
        <!-- è§†å›¾1: Poseæ£€æµ‹ -->
        <div class="view-panel">
            <div class="view-title" style="background: rgba(231, 76, 60, 0.9);">
                ğŸ“¹ MediaPipe Pose (33ç‚¹)
            </div>
            <canvas id="poseCanvas"></canvas>
            <div class="view-info" id="poseInfo">ç­‰å¾…å¯åŠ¨...</div>
        </div>
        
        <!-- è§†å›¾2: IMU 3D -->
        <div class="view-panel">
            <div class="view-title" style="background: rgba(155, 89, 182, 0.9);">
                ğŸ® IMU 3Dæ¨¡å‹
            </div>
            <canvas id="imuCanvas"></canvas>
            <div class="view-info" id="imuInfo">ç­‰å¾…è¿æ¥...</div>
        </div>
        
        <!-- è§†å›¾3: èåˆ -->
        <div class="view-panel">
            <div class="view-title" style="background: rgba(46, 204, 113, 0.9);">
                ğŸ¯ èåˆæ¨¡å¼
            </div>
            <canvas id="fusionCanvas"></canvas>
            <div class="view-info" id="fusionInfo">ç­‰å¾…æ ¡å‡†...</div>
        </div>
    </div>
    
    <video id="video" autoplay></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ========== å…¨å±€å˜é‡ ==========
        const SERVICE_UUID = '0000ffe5-0000-1000-8000-00805f9a34fb';
        const NOTIFY_CHAR_UUID = '0000ffe4-0000-1000-8000-00805f9a34fb';
        
        let pose = null;
        let hands = null;
        let camera = null;
        let imuChar = null;
        
        // Three.js
        let scene, camera3d, renderer, handModel;
        let scene2, camera3d2, renderer2, handModel2;
        
        // æ•°æ®
        const poseData = {
            detected: false,
            leftWrist: null,
            rightWrist: null
        };
        
        const handsData = {
            detected: false,
            landmarks: null
        };
        
        const imuData = {
            roll: 0, pitch: 0, yaw: 0
        };
        
        const imuOffset = {
            roll: 0, pitch: 0, yaw: 0
        };
        
        const fusionOffset = {
            x: 0, y: 0
        };
        
        // ========== MediaPipe Pose + Hands ==========
        async function startPose() {
            try {
                document.getElementById('poseStatus').textContent = 'å¯åŠ¨ä¸­';
                
                const video = document.getElementById('video');
                
                // åˆå§‹åŒ–Hands
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults(onHandsResults);
                
                // åˆå§‹åŒ–Pose
                pose = new Pose({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                    }
                });
                
                pose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                pose.onResults(onPoseResults);
                
                // å¯åŠ¨æ‘„åƒå¤´ï¼ˆç…§æ¬ä½ çš„æ–¹å¼ï¼‰
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 1280, height: 720 } 
                });
                video.srcObject = stream;
                
                await new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        resolve();
                    };
                });
                
                // ä½¿ç”¨Cameraå·¥å…·ï¼ˆç…§æ¬ä½ çš„æ–¹å¼ï¼‰
                camera = new Camera(video, {
                    onFrame: async () => {
                        await hands.send({image: video});
                        await pose.send({image: video});
                    },
                    width: 1280,
                    height: 720
                });
                
                await camera.start();
                
                document.getElementById('poseStatus').textContent = 'è¿è¡Œä¸­';
                document.getElementById('poseStatus').className = 'status active';
                
                console.log('âœ… Pose + Handså·²å¯åŠ¨');
                
            } catch (e) {
                console.error('å¯åŠ¨å¤±è´¥:', e);
                alert('å¯åŠ¨å¤±è´¥: ' + e.message);
            }
        }
        
        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handsData.detected = true;
                handsData.landmarks = results.multiHandLandmarks;
            } else {
                handsData.detected = false;
            }
        }
        
        function onPoseResults(results) {
            // æ›´æ–°Poseæ•°æ®
            if (results.poseLandmarks) {
                poseData.detected = true;
                poseData.leftWrist = results.poseLandmarks[15];
                poseData.rightWrist = results.poseLandmarks[16];
            } else {
                poseData.detected = false;
                poseData.leftWrist = null;
                poseData.rightWrist = null;
            }
            
            // ç»˜åˆ¶Poseè§†å›¾ï¼ˆåŒæ—¶ç»˜åˆ¶Handsï¼‰
            drawPose(results);
            
            // åœ¨Poseç”»é¢ä¸Šå åŠ èåˆæŒ‡ç¤ºï¼ˆå¦‚æœå·²æ ¡å‡†ï¼‰
            if (fusionOffset.x !== 0 || fusionOffset.y !== 0) {
                if (poseData.detected && poseData.rightWrist) {
                    const mirroredX = 1 - poseData.rightWrist.x;
                    drawFusionOverlay(mirroredX, poseData.rightWrist.y);
                }
            }
        }
        
        function drawPose(results) {
            const canvas = document.getElementById('poseCanvas');
            const ctx = canvas.getContext('2d');
            
            // åŠ¨æ€è®¾ç½®canvaså®é™…å°ºå¯¸
            if (canvas.width !== results.image.width || canvas.height !== results.image.height) {
                canvas.width = results.image.width;
                canvas.height = results.image.height;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // æ°´å¹³ç¿»è½¬ï¼ˆé•œåƒï¼‰
            ctx.save();
            ctx.scale(-1, 1);
            ctx.drawImage(results.image, -canvas.width, 0, canvas.width, canvas.height);
            ctx.restore();
            
            // ç»˜åˆ¶Poseéª¨éª¼
            if (results.poseLandmarks) {
                const landmarks = results.poseLandmarks;
                
                // ç»˜åˆ¶è¿çº¿
                const connections = [
                    [11,12],[11,13],[13,15],[12,14],[14,16],
                    [11,23],[12,24],[23,24],
                    [23,25],[25,27],[24,26],[26,28]
                ];
                
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                
                connections.forEach(([s, e]) => {
                    const start = landmarks[s];
                    const end = landmarks[e];
                    
                    if (start && end && start.visibility > 0.5 && end.visibility > 0.5) {
                        ctx.beginPath();
                        // é•œåƒç¿»è½¬xåæ ‡
                        ctx.moveTo((1 - start.x) * canvas.width, start.y * canvas.height);
                        ctx.lineTo((1 - end.x) * canvas.width, end.y * canvas.height);
                        ctx.stroke();
                    }
                });
                
                // ç»˜åˆ¶å…³é”®ç‚¹
                landmarks.forEach((p, idx) => {
                    if (p.visibility > 0.5) {
                        const x = (1 - p.x) * canvas.width;  // é•œåƒç¿»è½¬
                        const y = p.y * canvas.height;
                        
                        if (idx === 15 || idx === 16) {
                            // æ‰‹è…• - æ›´å¤§æ›´æ˜æ˜¾
                            ctx.fillStyle = '#ff0000';
                            ctx.beginPath();
                            ctx.arc(x, y, 12, 0, 2 * Math.PI);
                            ctx.fill();
                            
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(x, y, 18, 0, 2 * Math.PI);
                            ctx.stroke();
                            
                            ctx.fillStyle = '#ffffff';
                            ctx.font = 'bold 16px Arial';
                            ctx.fillText(idx === 15 ? 'å·¦æ‰‹è…•' : 'å³æ‰‹è…•', x + 25, y - 15);
                        } else {
                            ctx.fillStyle = '#00ff00';
                            ctx.beginPath();
                            ctx.arc(x, y, 4, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                });
            }
            
            // ç»˜åˆ¶Handséª¨éª¼ï¼ˆå åŠ ï¼‰
            if (handsData.detected && handsData.landmarks) {
                handsData.landmarks.forEach(handLandmarks => {
                    // ç»˜åˆ¶æ‰‹éƒ¨è¿çº¿
                    const handConnections = [
                        [0,1],[1,2],[2,3],[3,4],  // æ‹‡æŒ‡
                        [0,5],[5,6],[6,7],[7,8],  // é£ŸæŒ‡
                        [0,9],[9,10],[10,11],[11,12],  // ä¸­æŒ‡
                        [0,13],[13,14],[14,15],[15,16],  // æ— åæŒ‡
                        [0,17],[17,18],[18,19],[19,20]   // å°æŒ‡
                    ];
                    
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    
                    handConnections.forEach(([s, e]) => {
                        const start = handLandmarks[s];
                        const end = handLandmarks[e];
                        
                        ctx.beginPath();
                        // é•œåƒç¿»è½¬
                        ctx.moveTo((1 - start.x) * canvas.width, start.y * canvas.height);
                        ctx.lineTo((1 - end.x) * canvas.width, end.y * canvas.height);
                        ctx.stroke();
                    });
                    
                    // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹
                    handLandmarks.forEach((p, idx) => {
                        const x = (1 - p.x) * canvas.width;  // é•œåƒç¿»è½¬
                        const y = p.y * canvas.height;
                        
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                });
            }
            
            // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
            let info = '';
            if (poseData.detected) {
                info += `<strong style="color:#2ecc71;">âœ… Pose: æ£€æµ‹åˆ°</strong><br>`;
                info += `å·¦æ‰‹è…•: (${(poseData.leftWrist.x*100).toFixed(0)}%, ${(poseData.leftWrist.y*100).toFixed(0)}%)<br>`;
                info += `å³æ‰‹è…•: (${(poseData.rightWrist.x*100).toFixed(0)}%, ${(poseData.rightWrist.y*100).toFixed(0)}%)<br>`;
            } else {
                info += `<strong style="color:#e74c3c;">âŒ Pose: æœªæ£€æµ‹</strong><br>`;
            }
            
            if (handsData.detected) {
                info += `<strong style="color:#f1c40f;">âœ… Hands: ${handsData.landmarks.length}åªæ‰‹</strong>`;
            } else {
                info += `<strong style="color:#95a5a6;">âŒ Hands: æœªæ£€æµ‹</strong>`;
            }
            
            document.getElementById('poseInfo').innerHTML = info;
            
            // æ³¨æ„ï¼šèåˆå åŠ å±‚åœ¨animate3Dä¸­ç»˜åˆ¶ï¼Œè¿™é‡Œä¸éœ€è¦è°ƒç”¨
        }
        
        // ========== Three.jsåˆå§‹åŒ– ==========
        function initThreeJS() {
            // IMUè§†å›¾
            const canvas1 = document.getElementById('imuCanvas');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f0f1e);
            
            camera3d = new THREE.PerspectiveCamera(75, canvas1.clientWidth / canvas1.clientHeight, 0.1, 1000);
            camera3d.position.set(0, 1, 3);
            camera3d.lookAt(0, 0.5, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas: canvas1, antialias: true });
            renderer.setSize(canvas1.clientWidth, canvas1.clientHeight);
            
            const grid = new THREE.GridHelper(10, 10);
            scene.add(grid);
            
            const axes = new THREE.AxesHelper(2);
            scene.add(axes);
            
            const geometry = new THREE.BoxGeometry(0.8, 0.2, 0.4);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x9b59b6,
                transparent: true,
                opacity: 0.9
            });
            handModel = new THREE.Mesh(geometry, material);
            handModel.position.y = 0.5;
            scene.add(handModel);
            
            const fingerGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 16);
            const fingerMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const finger = new THREE.Mesh(fingerGeom, fingerMat);
            finger.position.set(0.3, 0, 0);
            finger.rotation.z = Math.PI / 2;
            handModel.add(finger);
            
            const localAxes = new THREE.AxesHelper(0.5);
            handModel.add(localAxes);
            
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 5, 5);
            scene.add(light);
            
            const ambient = new THREE.AmbientLight(0x404040);
            scene.add(ambient);
            
            // èåˆè§†å›¾
            const canvas2 = document.getElementById('fusionCanvas');
            
            scene2 = new THREE.Scene();
            scene2.background = new THREE.Color(0x0f0f1e);
            
            camera3d2 = new THREE.PerspectiveCamera(75, canvas2.clientWidth / canvas2.clientHeight, 0.1, 1000);
            camera3d2.position.set(0, 1, 3);
            camera3d2.lookAt(0, 0.5, 0);
            
            renderer2 = new THREE.WebGLRenderer({ canvas: canvas2, antialias: true });
            renderer2.setSize(canvas2.clientWidth, canvas2.clientHeight);
            
            const grid2 = new THREE.GridHelper(10, 10);
            scene2.add(grid2);
            
            const axes2 = new THREE.AxesHelper(2);
            scene2.add(axes2);
            
            const geometry2 = new THREE.BoxGeometry(0.8, 0.2, 0.4);
            const material2 = new THREE.MeshPhongMaterial({ 
                color: 0x2ecc71,
                transparent: true,
                opacity: 0.9
            });
            handModel2 = new THREE.Mesh(geometry2, material2);
            handModel2.position.y = 0.5;
            scene2.add(handModel2);
            
            const fingerGeom2 = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 16);
            const fingerMat2 = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const finger2 = new THREE.Mesh(fingerGeom2, fingerMat2);
            finger2.position.set(0.3, 0, 0);
            finger2.rotation.z = Math.PI / 2;
            handModel2.add(finger2);
            
            const localAxes2 = new THREE.AxesHelper(0.5);
            handModel2.add(localAxes2);
            
            const light2 = new THREE.DirectionalLight(0xffffff, 1);
            light2.position.set(5, 5, 5);
            scene2.add(light2);
            
            const ambient2 = new THREE.AmbientLight(0x404040);
            scene2.add(ambient2);
            
            animate3D();
        }
        
        let debugFrameCount = 0;
        
        function animate3D() {
            requestAnimationFrame(animate3D);
            
            // IMUè§†å›¾ï¼šåªæ˜¾ç¤ºå§¿æ€
            const roll = (imuData.roll - imuOffset.roll) * Math.PI / 180;
            const pitch = (imuData.pitch - imuOffset.pitch) * Math.PI / 180;
            const yaw = (imuData.yaw - imuOffset.yaw) * Math.PI / 180;
            
            handModel.rotation.set(roll, pitch, yaw, 'ZYX');
            handModel.position.set(0, 0.5, 0);
            
            // èåˆè§†å›¾ï¼šä½ç½® + å§¿æ€
            if (poseData.detected && poseData.rightWrist) {
                // é•œåƒåçš„åæ ‡
                const mirroredX = 1 - poseData.rightWrist.x;
                
                // æ˜ å°„åˆ°3Dç©ºé—´
                // Xè½´ï¼šå·¦å³ç§»åŠ¨æ‰‹ â†’ 3Dæ¨¡å‹å·¦å³ç§»åŠ¨
                const x = (mirroredX - 0.5 - fusionOffset.x) * 6;
                
                // Yè½´ï¼šä¸Šä¸‹ç§»åŠ¨æ‰‹ â†’ 3Dæ¨¡å‹ä¸Šä¸‹ç§»åŠ¨
                const y = -(poseData.rightWrist.y - 0.5 - fusionOffset.y) * 4;
                
                // Zè½´ï¼šå›ºå®šä¸å˜ï¼ˆä¸è¦æ·±åº¦å½±å“ï¼‰
                const z = 0;
                
                handModel2.position.set(x, y, z);
                
                // æ¯100å¸§è°ƒè¯•ä¸€æ¬¡
                debugFrameCount++;
                if (debugFrameCount % 100 === 0) {
                    console.log('èåˆ3Dä½ç½®:', x.toFixed(2), y.toFixed(2), z.toFixed(2));
                }
            }
            
            handModel2.rotation.set(roll, pitch, yaw, 'ZYX');
            
            renderer.render(scene, camera3d);
            renderer2.render(scene2, camera3d2);
        }
        
        // åœ¨Poseè§†é¢‘ä¸Šç»˜åˆ¶èåˆæ¨¡å¼çš„ç›’å­ä½ç½®æŒ‡ç¤º
        function drawFusionOverlay(mirroredX, wristY) {
            const canvas = document.getElementById('poseCanvas');
            const ctx = canvas.getContext('2d');
            
            if (!canvas || !ctx) return;
            
            // è®¡ç®—å±å¹•ä½ç½®
            const screenX = mirroredX * canvas.width;
            const screenY = wristY * canvas.height;
            
            // ç»˜åˆ¶3Dç›’å­ä¸­å¿ƒæŒ‡ç¤º
            ctx.save();
            
            // å¤–åœˆï¼ˆç»¿è‰²ï¼‰
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(screenX, screenY, 25, 0, 2 * Math.PI);
            ctx.stroke();
            
            // å†…åœˆï¼ˆç»¿è‰²å¡«å……ï¼‰
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(screenX, screenY, 25, 0, 2 * Math.PI);
            ctx.fill();
            
            // ä¸­å¿ƒç‚¹
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(screenX, screenY, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // åå­—çº¿
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(screenX - 15, screenY);
            ctx.lineTo(screenX + 15, screenY);
            ctx.moveTo(screenX, screenY - 15);
            ctx.lineTo(screenX, screenY + 15);
            ctx.stroke();
            
            // æ ‡ç­¾
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('3Dç›’å­ä¸­å¿ƒ', screenX + 30, screenY - 10);
            
            ctx.restore();
        }
        
        // ========== IMU ==========
        async function connectIMU() {
            try {
                const device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { namePrefix: 'WT901' },
                        { namePrefix: 'BS-BT' },
                        { namePrefix: 'BS91' }
                    ],
                    optionalServices: [SERVICE_UUID]
                });
                
                const srv = await device.gatt.connect();
                await new Promise(r => setTimeout(r, 2000));
                
                const s = await srv.getPrimaryService(SERVICE_UUID);
                imuChar = await s.getCharacteristic(NOTIFY_CHAR_UUID);
                
                await imuChar.startNotifications();
                imuChar.addEventListener('characteristicvaluechanged', onIMUData);
                
                document.getElementById('imuStatus').textContent = 'å·²è¿æ¥';
                document.getElementById('imuStatus').className = 'status active';
                
                console.log('âœ… IMUå·²è¿æ¥');
                
            } catch (e) {
                alert('IMUè¿æ¥å¤±è´¥: ' + e.message);
            }
        }
        
        function onIMUData(e) {
            const d = new Uint8Array(e.target.value.buffer);
            if (d.length !== 20 || d[0] !== 0x55 || d[1] !== 0x61) return;
            
            const roll_raw = ((d[15] << 8) | d[14]);
            const pitch_raw = ((d[17] << 8) | d[16]);
            const yaw_raw = ((d[19] << 8) | d[18]);
            
            imuData.roll = toInt16(roll_raw) / 32768 * 180;
            imuData.pitch = toInt16(pitch_raw) / 32768 * 180;
            imuData.yaw = toInt16(yaw_raw) / 32768 * 180;
            
            const roll = imuData.roll - imuOffset.roll;
            const pitch = imuData.pitch - imuOffset.pitch;
            const yaw = imuData.yaw - imuOffset.yaw;
            
            document.getElementById('roll').textContent = roll.toFixed(1) + 'Â°';
            document.getElementById('pitch').textContent = pitch.toFixed(1) + 'Â°';
            document.getElementById('yaw').textContent = yaw.toFixed(1) + 'Â°';
            
            document.getElementById('imuInfo').innerHTML = 
                `<strong style="color:#2ecc71;">Roll: ${roll.toFixed(1)}Â°</strong><br>` +
                `Pitch: ${pitch.toFixed(1)}Â°<br>` +
                `Yaw: ${yaw.toFixed(1)}Â°`;
        }
        
        function toInt16(v) { return v > 32767 ? v - 65536 : v; }
        
        // ========== æ ¡å‡† ==========
        function calibrateIMU() {
            if (!imuChar) {
                alert('âš ï¸ è¯·å…ˆè¿æ¥IMUä¼ æ„Ÿå™¨ï¼');
                return;
            }
            
            imuOffset.roll = imuData.roll;
            imuOffset.pitch = imuData.pitch;
            imuOffset.yaw = imuData.yaw;
            
            document.getElementById('calibStatus').innerHTML = 'âœ… IMUå·²æ ¡å‡†';
            console.log('âœ… IMUå·²æ ¡å‡†');
            
            alert('âœ… IMUè§’åº¦å·²æ ¡å‡†ï¼\n\nå½“å‰å§¿æ€å·²è®¾ä¸º0Â°å‚è€ƒç‚¹');
        }
        
        function calibrateFusion() {
            console.log('=== å¼€å§‹èåˆæ ¡å‡† ===');
            console.log('Poseæ£€æµ‹çŠ¶æ€:', poseData.detected);
            console.log('å³æ‰‹è…•æ•°æ®:', poseData.rightWrist);
            
            if (!poseData.detected || !poseData.rightWrist) {
                alert('âš ï¸ è¯·å…ˆå¯åŠ¨Poseå¹¶æ£€æµ‹åˆ°èº«ä½“ï¼\n\nç¡®ä¿å³æ‰‹åœ¨æ‘„åƒå¤´ç”»é¢ä¸­');
                return;
            }
            
            if (!imuChar) {
                alert('âš ï¸ è¯·å…ˆè¿æ¥IMUä¼ æ„Ÿå™¨ï¼');
                return;
            }
            
            // è®°å½•å½“å‰å³æ‰‹è…•ä½ç½®ä½œä¸ºä¸­å¿ƒç‚¹ï¼ˆé•œåƒåçš„åæ ‡ï¼‰
            const mirroredX = 1 - poseData.rightWrist.x;
            fusionOffset.x = mirroredX - 0.5;
            fusionOffset.y = poseData.rightWrist.y - 0.5;
            
            console.log('å³æ‰‹è…•åŸå§‹ä½ç½®:', poseData.rightWrist.x.toFixed(3), poseData.rightWrist.y.toFixed(3));
            console.log('é•œåƒåX:', mirroredX.toFixed(3));
            console.log('Offset X:', fusionOffset.x.toFixed(3), 'Y:', fusionOffset.y.toFixed(3));
            
            // åŒæ—¶æ ¡å‡†IMU
            imuOffset.roll = imuData.roll;
            imuOffset.pitch = imuData.pitch;
            imuOffset.yaw = imuData.yaw;
            
            console.log('IMU Offset:', imuOffset);
            
            document.getElementById('calibStatus').innerHTML = 
                'âœ… èåˆå·²æ ¡å‡†<br>å³æ‰‹è…•å¯¹é½';
            
            document.getElementById('fusionInfo').innerHTML = 
                `<strong style="color:#2ecc71;">âœ… å·²æ ¡å‡†</strong><br>` +
                `ç°åœ¨ç§»åŠ¨å³æ‰‹è§‚å¯Ÿ3Dæ¨¡å‹<br>` +
                `Offset: (${fusionOffset.x.toFixed(2)}, ${fusionOffset.y.toFixed(2)})`;
            
            console.log('=== æ ¡å‡†å®Œæˆ ===');
            
            alert('âœ… èåˆæ ¡å‡†å®Œæˆï¼\n\nâœ“ å³æ‰‹è…•ä½ç½® â†’ 3Dæ¨¡å‹ä¸­å¿ƒ\nâœ“ IMUå§¿æ€ â†’ 0Â°å‚è€ƒ\n\nç°åœ¨ç§»åŠ¨å³æ‰‹ï¼Œ3Dæ¨¡å‹ä¼šè·Ÿéšï¼');
        }
        
        // ========== åˆå§‹åŒ– ==========
        window.addEventListener('load', () => {
            initThreeJS();
            console.log('âœ… ä¸‰è§†å›¾æ¼”ç¤ºç³»ç»Ÿå·²åŠ è½½');
        });
        
        window.addEventListener('resize', () => {
            if (renderer && camera3d) {
                const canvas1 = document.getElementById('imuCanvas');
                camera3d.aspect = canvas1.clientWidth / canvas1.clientHeight;
                camera3d.updateProjectionMatrix();
                renderer.setSize(canvas1.clientWidth, canvas1.clientHeight);
            }
            
            if (renderer2 && camera3d2) {
                const canvas2 = document.getElementById('fusionCanvas');
                camera3d2.aspect = canvas2.clientWidth / canvas2.clientHeight;
                camera3d2.updateProjectionMatrix();
                renderer2.setSize(canvas2.clientWidth, canvas2.clientHeight);
            }
        });
    </script>
</body>
</html>
